## Пункт 1

**База данных** -- это совокупность данных, которые хранятся в соответствии с определенной схемой данных, манипулирование которыми производят в соответствии с определенными правилами.

**Модель данных** -- это формальная теория представления и обработки данных в СУБД, которая включает по меньшей мере такие аспекты:

* *Аспект структуры* -- методы описания типов и логических структур БД;
* *Аспект манипуляции* -- методы манипулирования данными.
* *Аспект целостности* -- методы описания и поддержки целостности БД.

Существующие разновидности баз данных:

* *Иерархическая модель*:
    - IBM, 1960-ые;
    - Первая СУБД: **IBM IMS** (в рамках космической программы *Аполлон*);
    - Древовидная структура записей;
    - Потомок имеет ровно 1 предка;
    - Потомки общего предка -- близнецы;
* *Сетевая модель*:
    - Чарльз Бахман, 1969;
    - Структура записей в виде графа;
	- Расширяет иерархическую модель данных;
	- Потомок может иметь более 1 предка;
* *Реляционная модель*:
	- Эдгар Кодд, 1969-1970;
	- В основе модели -- математика и логика;
	- Логическая модель данных;
	- Не зависит от физических структур;
	- Также Кодд представил язык **α**, который в дальнейшем сильно повлиял на создание *SEQUEL*;

## Пункт 2

**Реляционная модель**:

* Эдгар Кодд, 1969-1970;
* В основе модели -- математика и логика;
* Логическая модель данных;
* Не зависит от физических структур;
* Также Кодд представил язык **α**, который в дальнейшем сильно повлиял на создание *SEQUEL*;

Основные понятия:

* *Домен* -- множество значений;
* *Атрибут* -- наименование домена;
* *Кортеж* -- упорядоченный набор элементов фиксированной длины;
* *Декартово произведение*. Если заданы два множества $$R_1$$ и $$R_2$$, то множество $$R_1{\times}R_2=\{(x_1, x_2)|x_1{\in}R_1,x_2{\in}R_2\}$$ называется декартовым произведением этих множеств.

## Пункт 3

Семейство $$\chi{\in}2^X$$ называется **алгеброй**, если:

1. $$\varnothing{\in}\chi$$;
2. $$A{\in}\chi{\rightarrow}2^X{\backslash}A{\in}\chi$$;
3. $$A,B{\in}\chi{\rightarrow}A{\cup}B{\in}\chi$$

В реляционной алгебре носитель -- множество всевозможных отношений конечных порядков.

Ключевое понятие -- отношение.

* Нет двух одинаковых кортежей;
* Нет порядка кортежей;
* Нет порядка атрибутов;

Операции:
* Теоретико-множественные (применимы к совместимым отношениям):
    - *Пересечение*;
    - *Объединение*;
    - *Разность*;
* Реляционные:
    - *Проекция (Where)*: $$R[L]=\{r[L]|r{\in}R\}$$;
    - *Ограничение (Select)*: $$R[A{\theta}B]=\{r|r{\in}R\&(r[A]{\theta}r[B])\}$$;
    - *Соединение (Join)*: $$R_1[R_1[A_j]{\theta}R_2[B_j]]R_2=\{r_1{\times}r_2|r_1{\in}R_1\&r_2{\in}R_2\&r_1[A_j]{\theta}r_2[B_j]\}$$;

## Пункт 4

[Плейлист с хорошо рассказанной историей](https://www.youtube.com/watch?v=MgQO5cRUNM0&list=PLmqFxxywkatS8Hfj6-aYgXfrpvV6OoKSc)

Стандарты **SQL**:

* Sql-86 -- первая попытка формализации;
* $$\dots$$
* Sql-92 -- core-раздел стандарта;
* $$\dots$$
* Sql-2016;

Известно, что зачастую СУБД не поддерживают стандарт полностью.

## Пункт 5

**DDL (Data Defenition Language)** -- это семейство компьютерных языков, используемых в компьютерных программах для описания структуры баз данных. К ним относится и SQL.

Основные операции определения данных (*с примерами на языке SQL*):

* *Create* -- создание объекта БД;

```
    CREATE TABLE table_name(
        column_name_1 datatype_1,
        ...
        column_name_N datatype_N
    );
```
* *Alter* -- изменение объекта БД;

```
    ALTER TABLE table_name ADD column_name datatype;
```
* *Drop* -- удаление объектов из БД;

```
    DROP TABLE [IF EXISTS] table_name;
```
* *Truncate* -- удаление *содержимого* из объекта БД;

```
    TRUNCATE TABLE table_name;
```

## Пункт 6

# TODO

FROM $$\rightarrow$$ WHERE $$\rightarrow$$ GROUP BY $$\rightarrow$$ HAVING $$\rightarrow$$ SELECT $$\rightarrow$$ ORDER BY.

## Пункт 7

**JOIN** -- оператор языка SQL, который является реализацией операции соединения реляционной алгебры.

Таблицы для примеров:

| **cityid** | **cityname**    |
|------------|-----------------|
| 1          | Москва          |
| 2          | Санкт-Петербург |
| 3          | Казань          |

| **personname** | **cityid** |
|----------------|------------|
| Андрей         | 1          |
| Леонид         | 2          |
| Сергей         | 1          |
| Григорий       | 4          |

* *INNER* (по умолчанию) -- соединяет по ключу. Порядок таблиц для оператора неважен, поскольку оператор является коммутативным:

	```
	SELECT *
	FROM person INNER JOIN city
	ON person.cityid = city.cityid
	```
	
	| **personname** | **cityid** | **cityid** | **cityname**    |
	|----------------|------------|------------|-----------------|
	| Aндрей         | 1          | 1          | Москва          |
	| Леонид         | 2          | 2          | Санкт-Петербург |
	| Сергей         | 1          | 1          | Москва          |

* *CROSS* -- декартово произведение таблиц. орядок таблиц для оператора неважен, поскольку оператор является коммутативным:

	```
	SELECT *
	FROM person CROSS JOIN city
	```

	*Результат - попарное конкатенация всех пар кортежей.*

* *OUTER (LEFT | RIGHT | FULL)*:
    - **LEFT** -- порядок таблиц для оператора важен, поскольку оператор не является коммутативным.

		```
		SELECT *
		FROM person LEFT OUTER JOIN city
		ON person.cityid = city.cityid
		```
		
		| **personname** | **cityid** | **cityid** | **cityname**    |
		|----------------|------------|------------|-----------------|
		| Aндрей         | 1          | 1          | Москва          |
		| Леонид         | 2          | 2          | Санкт-Петербург |
		| Сергей         | 1          | 1          | Москва          |
		| Григорий       | 1          | NULL       | NULL            |
		
    - **Right** -- порядок таблиц для оператора важен, поскольку оператор не является коммутативным.

		```
		SELECT *
		FROM person RIGHT OUTER JOIN city
		ON person.cityid = city.cityid
		```

		| **personname** | **cityid** | **cityid** | **cityname**    |
		|----------------|------------|------------|-----------------|
		| Aндрей         | 1          | 1          | Москва          |
		| Леонид         | 2          | 2          | Санкт-Петербург |
		| Сергей         | 1          | 1          | Москва          |
		| NULL           | NULL       | 3          | Казань          |
		
	- **FULL** -- порядок таблиц для оператора неважен, поскольку оператор является коммутативным. 
	
		```
		SELECT *
		FROM person FULL OUTER JOIN city
		ON person.cityid = city.cityid
		```
		
		| **personname** | **cityid** | **cityid** | **cityname**    |
		|----------------|------------|------------|-----------------|
		| Aндрей         | 1          | 1          | Москва          |
		| Леонид         | 2          | 2          | Санкт-Петербург |
		| Сергей         | 1          | 1          | Москва          |
		| NULL           | NULL       | 3          | Казань          |
		| Григорий       | 1          | NULL       | NULL            |

## Пункт 9

**Транзакция** -- это группа *последовательных* операций с базой данных, которая представляет собой *логическую единицу работы с данными*, гарантированно переводящая БД *из одного непротиворечивого состояния в другое*.

Операции:

* *Commit* -- применение изменений;
* *Rollback* -- отмена изменений (откат до предыдущей успешной транзакции);
* *Save point* -- точка останова (находится внутри транзакции);

ACID:

* **A***tomicity* -- выполнены либо все подоперации, либо никакие;
* **C***onsistency* -- каждая успешная транзакция фиксирует только допустимые результаты;
* **I***solation* -- параллельные транзакции не влияют на результаты друг друга;
* **D***urability* -- вне зависимости от сбоев системы результаты успешных транзакций сохранятся в системе;

# Пункт 10

На практике транзакции пытаются влиять на результаты выполнения друг друга, в результате чего возникают проблемы поддержки изолированности.

* Потерянное обновление -- изменение одного блока данных несколькими транзакциями;
* Грязное чтение -- чтение данных, измененных впоследствии откатившейся транзакцией;
* Неповторяющееся чтение -- повторное чтение измененных данных одной и той же транзакцией;
* Чтение фантомов -- взаимосвязанные критерии изменения данных двумя транзакциями;

Уровни изолированности:

* *Read uncommitted* -- данные блокируются на время внесения изменений, гарантирует отсутствие *потерянных обновлений*;
* *Read committed* -- решает проблему *грязного чтения*, реализация различна в разных СУБД;
	- Блокирование читаемых и изменяемых данных;
	- Сохранение нескольких версий параллельно изменяемых строк;
* *Repeatable read* -- никакая транзакция не может изменять данные, читаемые
текущей транзакцией, пока чтение не завершено. Решает проблему *неповторяющегося чтения*.
* *Serializable* -- транзакции полностью изолированы друг от друга.

# Пункт 11

**Троичная логика** -- это логика, в которой есть следующие допустимые значения логических выражений: True, False и NULL.


* *AND*

	|           | **True** | **False** | **NULL** |
	|-----------|----------|-----------|----------|
	| **True**  | True     | False     | NULL     |
	| **False** | False    | True      | False    |
	| **NULL**  | NULL     | False     | NULL     |

* *OR*

	|           | **True** | **False** | **NULL** |
	|-----------|----------|-----------|----------|
	| **True**  | True     | True      | True     |
	| **False** | True     | False     | NULL     |
	| **NULL**  | True     | NULL      | NULL     |

* *NOT*

	| **True**  | **False** | **NULL**  |
	|-----------|-----------|-----------|
	| **False** | **True**  | **NULL**  |

В SQL:

* Для работы с NULL используются отдельные операторы: **IS NULL** и **IS NOT NULL**.
* **= и != не работают с NULL.**
* Для *UNION*, *INTERSECT*, *EXCEPT NULL* -- это *NULL*.
* Для *JOIN NULL* -- не *NULL*.

Агрегрирующие функции:

* *sum*, *avg* -- не учитывают NULL;
* *min*, *max* -- работают с NULL (выводят *NULL*, если кроме *NULL* значений никаких нет);

## Пункт 12

**Проектирование базы данных** -- процесс создания детализированной модели данных* БД, а также необходимых ограничений целостности.

Основные задачи проектирования БД:

* Обеспечение хранения в БД всей необходимой информации;
* Обеспечение возможности получения данных по всем необходимым запросам;
* Сокращение избыточности и дублирования данных;
* Обеспечение целостности базы данных;

Этапы проектирования:

* Концептуальное (инфологическое) проектирование;
* Логическое (даталогическое) проектирование;
* Физическое проектирование;

Шаги проектирования:

1. Определение данных, которые будут храниться в БД:
	- Какую предметную область описываем?
	- Как будем описывать? Как будем детализировать?
2. Определение взаимосвязей между элементами данных:
	- Определили предметную область и детализировали разбиение на сущности;
	- Необходимо установить взаимосвязи;
3. Наложение логической структуры на данные:
	- Уже имеем концептуальную схему;
	- Хотим получить больший уровень детализации:
		* Уточнение атрибутивного состава;
		* Уточнение ограничений, накладываемых на атрибутивный состав;
		* Нормализация отношений;
		* В некоторых случаях допускается уточнение типа атрибута;
4. Создание спроектированной базы в СУБД;
